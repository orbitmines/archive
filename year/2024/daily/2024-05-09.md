

fromo before the weekend


odid  
  
I'm afraid thay if based on the title you expected I'd show up with one, I'm afraid that's the point I wanted to make at the start. Instead let me show you something better. Because you don't make this. There's insane complexity in software, compilers, hardware. If you can't have better tooling for that...  
  
I'll give it away right away, because there is no videogame yet build. But that is also part of my point. That's not how you do it. You need better infrastructure, you need better tools.  
  
The problem is that people go after making the game, making the thing. If it cannot be used as a tool and cannot make our current tools more useful. You need better infrastructure  
  
This is a pattern you see throughout the history of every programming language, you build it using your current tools, then you rebuilt it using your own tool. But then often you're stuck in your tool. And you need this pattern to repeat, but ...  
  
The actual problem is this  
We don't have good ways of dealing with things concurreny, in parallel  
We don't have good ways of dealing with histories, partial histories: casual histories  
We don't have good ways of dealing with ambiguity  
We don't have good ways of dealing with exploration  
We don't have good ways of combining all these tools people have built and explore them  
  
  
Or in short if you can't use your game as a tool to solve these kinds of problems, you're always going to shoot yourself in the foot or something  
  
If you can't use your game as a tool to solve the kinds of problems these kinds of projects are trying to solve, you'll never get there.  
  
It is not a problem of making the game, it has never been the problem of making a game. It has always been a problem of infrastructure. If you can't take all this and have access through it in your game, you'll not solve this problem. So what have I actually done other?; Fair enough  
  
It's always you're in a particular context, you escape that context, and make something new  
  
What you need is the ability to start churning away at possible interfaces, but for that.
