
A. Interpretation and Reinterpretation of existing Software
- What is a useful Universal Language in which to compare all existing languages?
	- [A Program in Ray](https://github.com/orbitmines/ray/blob/main/Ether/.ray/Program.ray)
- How do you compare [thousands](https://github.com/orbitmines/ray/blob/main/Ether/library/Index.ray) of languages, without redefining all the semantics by hand? (using their existing implementations)
- 
B. Gamification of Science, Engineering and Education
- What would be an example problem, and example reimplementation of that problem as a game?
- How do you model the existing knowledge of a player?
	- How do you initially calibrate the existing knowledge of a player?
- How do you tailor the interface to each player? ; When/How would you add to that arsenal?
- Quest Discovery: How do you generate/find quests relevant relative to some model one has of a player's knowledge?
- Quest Effectiveness: How does the reward of the quest influence our future?
- Quest Difficulty Rating: How do you assign a difficulty rating to a quest, relative for the character completing it.
- What primitives do you need to program NPC Quest selection?
C. Platform and L