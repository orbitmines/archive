
A. Interpretation and Reinterpretation of existing Software
- What is a useful Universal Language in which to compare all existing languages?
	- [A Program in Ray](https://github.com/orbitmines/ray/blob/main/Ether/.ray/Program.ray)
- How do you compare [thousands](https://github.com/orbitmines/ray/blob/main/Ether/library/Index.ray) of languages, without redefining all the semantics by hand? (using their existing implementations)
- 
B. Gamification of Science, Engineering and Education
- What would be an example problem, and example reimplementation of that problem as a game?
- How do you model the existing knowledge of a player?
	- How do you initially calibrate the existing knowledge of a player?
- How do you tailor the interface to each player? ; When/How would you add to that arsenal?
- Quest Discovery: How do you generate/find quests relevant relative to some model one has of a player's knowledge?
- Quest Effectiveness: How does the reward of the quest influence our future?
- Quest Difficulty Rating: How do you assign a difficulty rating to a quest, relative for the character completing it.
- Quest Progress: What would be intermediate feedback states to communicate?
- Quest Completion: How do you verify the solution?
- What primitives do you need to program NPC Quest selection?
- Translatability: What makes a problem translatable into a game?
C. The Ray Programming Language
- I. 
	- Should you superpose concurrent accesses of a variable?
	- Is a function's control-graph without an initial boundary: a starting point, a valid function?
	- How do you run a function backwards?
	- How do you call and define inverses of functions?
	- 
- II.
	- How do you scale large game graphs to millions of players?
- III.