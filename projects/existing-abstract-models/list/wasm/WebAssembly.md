"I believe I was first exposed to WebAssembly while working on a project using Blazor in the .NET ecosystem back in 20XX"

```tsx
  const WebAssemblyReference = <Reference is="reference" index={referenceCounter()} title="WebAssembly" link="https://webassembly.github.io/spec/core/_download/WebAssembly.pdf" simple inline />;  
  
  const WebAssemblyBinaryReference = <Reference is="reference" index={referenceCounter()} title="binary" link="https://webassembly.github.io/spec/core/binary/index.html" simple inline />;  
  
  const WebAssemblyTextualReference = <Reference is="reference" index={referenceCounter()} title="textual" link="https://webassembly.github.io/spec/core/text/index.html" simple inline />;  
  ****
```

```typescript
// [] -> 𝜖  
// ray.length -> |s|  
// ray[i] -> s[i]  
// ray[i : n] -> s[i] ... s[i + n - 1]
```

- [[wasm3]], [spec](https://github.com/WebAssembly/spec)

---

Since our only care for this challenge is density, any form of redundancy can be ruled out. As such we can directly start eliminating whole ranges of possibilities for showing the smallest signs of redundancy. (some function of what is valid redundancy because one doesn't yet know how to make it smaller) Size of functional ref & definition is smaller than redundant usage throughout the code. (for a specif value, for a whole supoposition of values)  

---

Define all these conclusions drawn which don't actually use wasm code, as assumptions (which need to be validated in some sense or could possible be violated by the implementstion of the wasm abstraction.  

---

Nice feature of the wasm binary is we can export the compress/decompress function from the same binary, and their order in the binary has some invariance. Which simplifies are definition of the search space: We're looking for a dual function export from a single binary.

Use the structure modelled of WebAssembly (binary representation) as the encoding of the hyperedges? Has the features or streaming the sequence, possible parallelism in the function streaming built in if not already supported, browsers (high adaptability, no separate encoding). --> This encoding the hyperedge model of wrbassembly in webessembly. (adopting)

### WebAssembly redundancies

We use up resources in order to allow for the awareness of some conceived invariance (symmetry), which lowers the search space (if that route is chosen), but interestingly increases possible interactions (does this increase/decrease the search space?) out of this realization of invariance. ; we remove some redundancy by setting up this invariance. (if the storage of this invariance realization is lower than the possibilities enabled by this invariance) ; One is basically setting up a possible nontrivial superposition through that invariance.;
