"I believe I was first exposed to WebAssembly while working on a project using Blazor in the .NET ecosystem back in 20XX"

```tsx
  const WebAssemblyReference = <Reference is="reference" index={referenceCounter()} title="WebAssembly" link="https://webassembly.github.io/spec/core/_download/WebAssembly.pdf" simple inline />;  
  
  const WebAssemblyBinaryReference = <Reference is="reference" index={referenceCounter()} title="binary" link="https://webassembly.github.io/spec/core/binary/index.html" simple inline />;  
  
  const WebAssemblyTextualReference = <Reference is="reference" index={referenceCounter()} title="textual" link="https://webassembly.github.io/spec/core/text/index.html" simple inline />;  
  ****
```

```typescript
// [] -> 𝜖  
// ray.length -> |s|  
// ray[i] -> s[i]  
// ray[i : n] -> s[i] ... s[i + n - 1]
```

- [[wasm3]], [spec](https://github.com/WebAssembly/spec)

### WebAssembly redundancies

We use up resources in order to allow for the awareness of some conceived invariance (symmetry), which lowers the search space (if that route is chosen), but interestingly increases possible interactions (does this increase/decrease the search space?) out of this realization of invariance. ; we remove some redundancy by setting up this invariance. (if the storage of this invariance realization is lower than the possibilities enabled by this invariance) ; One is basically setting up a possible nontrivial superposition through that invariance.;
