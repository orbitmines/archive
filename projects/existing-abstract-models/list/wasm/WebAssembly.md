"I believe I was first exposed to WebAssembly while working on a project using Blazor in the .NET ecosystem back in 20XX"

```tsx
  const WebAssemblyReference = <Reference is="reference" index={referenceCounter()} title="WebAssembly" link="https://webassembly.github.io/spec/core/_download/WebAssembly.pdf" simple inline />;  
  
  const WebAssemblyBinaryReference = <Reference is="reference" index={referenceCounter()} title="binary" link="https://webassembly.github.io/spec/core/binary/index.html" simple inline />;  
  
  const WebAssemblyTextualReference = <Reference is="reference" index={referenceCounter()} title="textual" link="https://webassembly.github.io/spec/core/text/index.html" simple inline />;  
  ****
```

```typescript
// [] -> 𝜖  
// ray.length -> |s|  
// ray[i] -> s[i]  
// ray[i : n] -> s[i] ... s[i + n - 1]
```

- [[wasm3]], [spec](https://github.com/WebAssembly/spec)

---

Since our only care for this challenge is density, any form of redundancy can be ruled out. As such we can directly start eliminating whole ranges of possibilities for showing the smallest signs of redundancy. (some function of what is valid redundancy because one doesn't yet know how to make it smaller) Size of functional ref & definition is smaller than redundant usage throughout the code. (for a specif value, for a whole supoposition of values)  

### WebAssembly redundancies

We use up resources in order to allow for the awareness of some conceived invariance (symmetry), which lowers the search space (if that route is chosen), but interestingly increases possible interactions (does this increase/decrease the search space?) out of this realization of invariance. ; we remove some redundancy by setting up this invariance. (if the storage of this invariance realization is lower than the possibilities enabled by this invariance) ; One is basically setting up a possible nontrivial superposition through that invariance.;
