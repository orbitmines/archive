


- [Higher Order Company - Origins of the HVM (2023)](https://www.youtube.com/watch?v=UQNNs77SpXA)


- [ ] https://zicklag.github.io/blog/interaction-nets-combinators-calculus/
- [ ] https://lambdaexplorer.com/


As eluded to in https://github.com/Kindelia/HVM/blob/master/guide/HOW.md:
References are indeed the course of many problems, but they are necessary. In the same way that a lambda function `(@x(* x 2) 21)`, expresses a reference. A reference being no more than a bidirectional relationship, one which isn't necessarily reversible perfectly, but represents one all the same. For example this lambda expression: The relationship between reducing to `(* 21 2)` and re-expanding to `(@x(* x 2) 21)`. Where this re-expansion represent just one of the possible re-expansions. Since reduces remove information, we wouldn't necessarily know which rule was applied. This sort of line of thinking is well-explored and relates to discussions around 'inverse' problems, the inverse through loss of information, generally considered a harder problem.

The references referred to in `HOW`, simply have more complexity than the close proximity references/structure/semantics of lambdas.

